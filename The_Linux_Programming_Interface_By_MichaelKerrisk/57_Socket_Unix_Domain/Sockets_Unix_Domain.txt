UNIX domain sockets, allows communication between processes on the same host system.

UNIX domain socket Addresses: struct socketaddr_un

struct sockaddr_un {
    sa_family_t sun_family; /*Always AF_UNIX*/
    char sun_path[108]; /*Null-terminated socket pathname*/
};


Binding UNIX domain socket:
___________________________
const char *SOSKNAME = "/tmp/mysock";
int sfd;
struct sockaddr_un addr;

sfd = socket(AF_UNIX, SOCK_STREAM, 0);
if(sfd == -1)
    errExit("SOCKET");

memset(&addr, 0, sizeof(struct sockaddr_un));   // Clear structure
addr.sun_family = AF_UNIX;                      // UNIX Domain address
strcpy(addr.sun_path, SOCKNAME, sizeof(addr.sun_path)-1); // To ensure this fiels alswys terminates /0

if(bind(sfd, (struct sockaddr*)&addr, sizeof(struct sockaddr_un)) == -1)
    errExit("bind");

bind() creates an entry in file system. Directory specified as part of the socket pathname needs to be 
accessible and writable.
Ownership of file is determined according to usual rules of file creation.
The file is marked as socket.

slat() returns S_IFSOCK in file-type component of st_mode field of st structure.

Although UNIX domain sockets are identified by pathnames, I/O on these sockets doesn't involve operations on
the underlying device.

Binding UNIX domain socket:
1)  We can't bind socket to an existing pathname -> error EADDRINUSE
2)  If usual to bind a socket to an absolute pathname, so that socket resides at a fixed 
address in the file system. 
Using relative pathname is possible, but unusual, because it requires an application that wants to connect()
to this socket to know the current working directory of applciaiton that performs bind().
3)  A socket may be bound to only on epathname: conversly a pathname can be bound to only one socket.
4)  We can't use open() to open socket
5)  What the socket is no longer required, its pathname entry can be removed using unlink()


Unix domain socket permission:
To connect Unix domain stream socket, write permission is required on the socket file.
To send datagram to UNIX domain datagram socket, write permission is required on socket file.

Execute(search) permission is required on each of directories in the socket pathname.


Creating a connected socket pair: socketpair()
Sometime it is useful a single process to create a pair of sockets and connect then together.

1) [socket() and bind()] 
2) [listen(), connect() and accept()] 
socketpair() provides shorthand to all these operations

int socketpair(int domain, int type, int protocol, int sockfd[2]);
    // Returns 0 on success or -1 on error

After socketpair() is called, process then create child via fork(), the child inherits copies of 
parent's fds including socket fds. The parent and child can use socket pair for IPC.
Sockets created from this are not attached with any address, so not visible to any other process.

The linux abstract socket namespace:
Bind UNIX domain socket to a name without being created in the file system.

    We don't need to worry about possible collisionswith existing names in the file system.

    It is not necessary to unlink the socket pathname when we have unfinished using the socket. The
    abstract name is automatically removed when socket is closed.

    We don't need to create a file-system pathname for the socket. It is useful in chroot environment or
    we don't ahve file access.


To create an abstract binding, we specify the first byte of sun_path deild as null byte.

Initial null byte is used to distinguish an abstract socket name.




Update shared variable with use of mutex to ensure that only one thread at a time can access the variable.

Mutexes ensure atomic access to any shared resources but used to protecting access to shared resources.
Mutexes are implemented using atomic machine-language operations (performed on memory locations visible
to all threads) and require system calls only in case of lock contention.

A mutex has two states locked and unlocked.
At any moment, only one thread can hold the lock on a mutex. Attempting to lock a mutex that is already
locked either blocks or fails with an error.
When a thread locks a mutex, it becomes owner of mutex, only the mutex owner can unlock the mutex.
Thread employs following protocol for accessing a resource,
    - Lock the mutex for shared resource
    - Access the shared resource
    - Unlock the mutex

Mutex can either be allocated as a static or created dynamically at run time. 

-------------------------------------
pthread_mutex_t
pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER; // Statically allocated mutexes

#include <pthread.h>
int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);
    // Both returns 0 on success or a positive error number on error

If the calling thread itself has already locked mutex, one of two implementation defined possibilities
may result deadlocks, blocked thread trying to lock a mutex that it already owns or the call fails, returning
EDEADLK. 

Error for unlocking mutex, is that unlocking mutex that is not locked or not locked by calling thread.

pthread_mutex_trylock() -> It tries to lock mutex, if already locked then fails with error EBUSY.
pthread_mutex_timedlock() -> Same as pthread_mutex_lock(), caller can specify additional argument as abstime,
that places limit waiting time for acquiring the mutex. If timer expires without caller being owner of mutex,
then it returns with error ETIMEDOUT.
---------------------------------------

Mutex Deadlocks:

            Thread A                                        Thread B                                        
1. pthread_mutex_lock(&mutex1);                 1. pthread_mutex_lock(&mutex2);
2. pthread_mutex_lock(&mutex2;)                 2. pthread_mutex_lock(&mutex1);
                    blocks                                             blocks
Both thread remains blocked, its deadlopck

Simple way to avoid such deadlocks, is to define mutex hierarchy. Two threads should lock mutexes in same order

Or use pthread_mutex_trylock() so that it returns error EBUSY. 

----------------------------------------
Dynamically initializing Mutex:

int pthread_mutex_init(pthread_mutex_t *mtx, const pthread_mutexattr_t *attr);
    // Returns 0 on success, or positive number on error
    // attr = NULL for default parameters

Mutex can be dynamically allocated on heap.
If mutex is automatic variable allocated on the stack.

int pthread_mutex_destroy(pthread_mutex_t *mtx)
    // Returns 0 on success, or positive error number on error

----------------------------------------
Mutex types:
PTHREAD_MUTEX_NORMAL: Deadlock detection is not provided. This is prone to deadlocks.

PTHREAD_MUTEX_ERRORCHECK: Error checking is performed on all operations

PTHREAD_MUTEX_RECURSIVE: This mutex maintain lock count.

____________________________________________________________________________________________________________

Signaling changes of state: Condition Variables


